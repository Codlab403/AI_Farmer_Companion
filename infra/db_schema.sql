-- AI Farmer's Companion - Supabase/PostgreSQL Schema
-- Version 1.0

-- Notes:
-- Supabase handles user authentication via its built-in `auth.users` table.
-- This schema defines tables for application-specific data.
-- We use a `profiles` table to store public user data linked to `auth.users`.

-- Enable Row Level Security (RLS) on tables and define policies as needed.

-- Profiles Table (linked to auth.users)
CREATE TABLE public.profiles (
    id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    phone_number TEXT UNIQUE,
    preferred_language VARCHAR(5) DEFAULT 'en', -- ISO 639-1 codes e.g., 'am', 'om', 'so', 'ti', 'en'
    region TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
-- Add policies for profiles table (e.g., users can view their own profile, update their own profile)
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Function to automatically update `updated_at` timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at() 
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for profiles updated_at
CREATE TRIGGER on_profiles_updated
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_updated_at();

-- Chat History Table
CREATE TABLE public.chat_history (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL, -- Allow keeping history if profile is deleted, or CASCADE
    session_id TEXT, -- Can be generated by the client or server for a conversation session
    query_text TEXT,
    response_text TEXT,
    language VARCHAR(5),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_offline_query BOOLEAN DEFAULT FALSE,
    metadata JSONB -- For storing additional context, like model used, confidence, etc.
);
ALTER TABLE public.chat_history ENABLE ROW LEVEL SECURITY;
-- Add policies for chat_history (e.g., users can only access their own chat history)
CREATE POLICY "Users can manage their own chat history" ON public.chat_history FOR ALL USING (auth.uid() = user_id);

-- Crop Advisory Cache (for offline crop & weather intelligence)
CREATE TABLE public.crop_advisory_cache (
    id BIGSERIAL PRIMARY KEY,
    latitude DECIMAL(9,6) NOT NULL,
    longitude DECIMAL(9,6) NOT NULL,
    crop_type TEXT,
    advisory_date DATE NOT NULL,
    weather_forecast_data JSONB, -- Store structured forecast from Tomorrow.io/Open-Meteo
    crop_tips_data JSONB, -- Store structured tips, potentially multilingual
    fetched_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    CONSTRAINT uq_advisory_location_date_crop UNIQUE (latitude, longitude, advisory_date, crop_type)
);
ALTER TABLE public.crop_advisory_cache ENABLE ROW LEVEL SECURITY;
-- Policies for crop_advisory_cache (likely more open for reads, restricted for writes)
CREATE POLICY "Allow public read access to advisory cache" ON public.crop_advisory_cache FOR SELECT USING (true);
-- Writes should be handled by a trusted service role or specific backend logic.

-- Pest Diagnosis Reports
CREATE TABLE public.pest_diagnosis_reports (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    image_storage_path TEXT, -- Path in Supabase Storage, e.g., 'user_pest_images/user_id/image_name.jpg'
    crop_type TEXT,
    region TEXT,
    symptoms_description TEXT, -- User-provided text description
    diagnosis_result JSONB, -- Store structured diagnosis: name, advice, confidence, model_used
    reported_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_offline_report BOOLEAN DEFAULT FALSE,
    requires_sync BOOLEAN DEFAULT FALSE -- For offline reports needing server processing
);
ALTER TABLE public.pest_diagnosis_reports ENABLE ROW LEVEL SECURITY;
-- Add policies for pest_diagnosis_reports (users can manage their own reports)
CREATE POLICY "Users can manage their own pest reports" ON public.pest_diagnosis_reports FOR ALL USING (auth.uid() = user_id);

-- Market Price Cache
CREATE TABLE public.market_price_cache (
    id BIGSERIAL PRIMARY KEY,
    region TEXT NOT NULL,
    crop_type TEXT NOT NULL,
    price_date DATE NOT NULL,
    price_data JSONB NOT NULL, -- Store structured price: value, unit, source (ECX, coop)
    trend_advice TEXT,
    fetched_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    CONSTRAINT uq_market_price_region_crop_date UNIQUE (region, crop_type, price_date)
);
ALTER TABLE public.market_price_cache ENABLE ROW LEVEL SECURITY;
-- Policies for market_price_cache (similar to advisory cache)
CREATE POLICY "Allow public read access to market price cache" ON public.market_price_cache FOR SELECT USING (true);
-- Writes should be handled by a trusted service role.

-- Note: Further tables might be needed for:
-- - Detailed crop information (planting guides, varieties, etc.)
-- - Supported languages and their localized strings (if not handled in-app or via JSONB)
-- - USSD/IVR session state if more complex than simple request/response

-- Example of how to create a trigger for other tables' updated_at columns:
-- CREATE TRIGGER on_chat_history_updated
--   BEFORE UPDATE ON public.chat_history
--   FOR EACH ROW
--   EXECUTE PROCEDURE public.handle_updated_at(); -- Assuming chat_history gets an updated_at column
